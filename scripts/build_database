#!/usr/bin/env ruby

require 'tempfile'

COVER_DIR = "filed/187500px"
DATABASE_DIR = "database"
ASSET_DIR = "scripts/"

STEGO_FILE = File.join(ASSET_DIR,"war_and_peace.txt")
STEGO_DATA = IO.read(STEGO_FILE)
STEGO_START_SIZE = 5000
$last_stego = -1

def main
	cover_images = Dir["#{COVER_DIR}/*.{jpg,jpeg}"]

	cover_images.each do |cover_image|
		cover_file = File.absolute_path(cover_image)
		
		#Going to use the hashed signature (the file basename) to seed a RNG.  This RNG will be used to make
		#decisions about what will happen with the image in terms of stego/no stego, formats, etc.  But we
		#want the same decision made for any given image each time in case we need to re-run the script

		hash = File.basename(cover_file, File.extname(cover_file))
		seed = hash.to_i(16)
		rng = Random.new(seed)

		#should_stego = rng.rand(0..1)

		images = []

		images << {:image=>cover_image, :db=>"baseline"}
		images << {:image=>gotham(cover_image), :db=>"gotham"}
		# images << {:image=>toaster(cover_image), :db=>"toaster"}
		# images << {:image=>nashville(cover_image), :db=>"nashville"}
		# images << {:image=>lomo(cover_image), :db=>"lomo"}
		# images << {:image=>kelvin(cover_image), :db=>"kelvin"}
		# images << {:image=>tiltshift(cover_image), :db=>"tiltshift"}	

		images.each do |image|
			db(stego(image[:image]), classify(hash, image[:db], "stego"))
			db(image[:image], classify(hash, image[:db], "cover"))
		end
	end
end


def classify(hash, db, category, *classifications)
	"#{db}/#{category}/#{hash[0..16]}.jpg"
end

def db(input, name)
	path = File.join(DATABASE_DIR, name)
	FileUtils.mkdir_p File.dirname(path)
	FileUtils.cp(input, path)
	puts "Saving "+name
end

def convert(input, command) 
	temp_file = Tempfile.new(["im_convert", ".jpg"])

	`convert "#{input}" #{command} "#{temp_file.path}"`

	return temp_file.path
end

#Helper methods.  These each should take an image path, perform some kind of manipulation on it using temp files, and return the temp file name.  This way they can be composed together


#Most of these are adapted from instagraph https://github.com/webarto/instagraph

def size(input) 
	info = `identify "#{input}"`
	width, height = info.match(/(\d+)x(\d+)\+/).captures
	return width.to_i, height.to_i
end

def lomo(input)
	converted = convert input, "-channel R -level 33% -channel G -level 33%"
	vignette converted
end

def frame(input, frame) 
	    framefile = File.join(ASSET_DIR, frame)
	    width, height = size(input)
    convert input, "\\( #{framefile} -resize #{width}x#{height}! -unsharp 1.5x1.0+1.5+0.02 \\) -flatten"
end

def stego(input) 
	#outguess needs this to be a jpg instead of jpeg. dumb, whatever.
	cover_file = Tempfile.new(["cover", ".jpg"])
	FileUtils.cp(input, cover_file)


	temp_file = Tempfile.new(["stego", ".jpg"])
	message_file = Tempfile.new(["message",".txt"])

	result_code = 1
	stego_size = STEGO_START_SIZE
	attempts = 0
	decay_rate = 0.01
	$last_stego = 0

	while(result_code != 0) do
		stego_size = (STEGO_START_SIZE * (1-(decay_rate*attempts))).round.to_i
		#puts "Trying #{stego_size}"
		File.open(message_file, 'w') do |file| 
			file.write(STEGO_DATA[0..stego_size])
		end

		cmd = "outguess -p 100 -d \"#{message_file.path}\" \"#{cover_file.path}\" \"#{temp_file.path}\" 2>&1"

		result = `#{cmd}`
		# puts result
		result_code = $?.to_i
		# puts "return: "+result_code.to_s
		attempts = attempts +1
		$last_stego = stego_size
	end

	puts "Worked at #{$last_stego}"

	$last_stego = stego_size

	temp_file.path
	
end

def nashville(input) 
	first = colortone(input, :color=>"#222b6d", :level=>100, :type=>0)
	second = colortone(first, :color=>"#f7daae", :level=>100, :type=>1)
	nashvilled = convert second, "-contrast -modulate 100,150,100 -auto-gamma"
	frame nashvilled, "Nashville"
end

def colortone(input, options={})
	options = {type: 0}.merge(options)

	temp_file = Tempfile.new(["colortone", ".jpg"])

	color = options[:color]
	args0 = options[:level]
	args1 = 100 - options[:level]
	negate = options[:type] == 0 ? "-negate": ""

	convert(input, "-set colorspace RGB \\( -clone 0 -fill '#{color}' -colorize 100% \\) \\( -clone 0 -colorspace gray #{negate} \\) -compose blend -define compose:args=#{args0},#{args1} -composite ")
end

def vignette(input, options={}) 
	options = {color1: "none", color2: "black", crop_factor: 1.5}.merge(options)

	crop_factor = options[:crop_factor]

	width, height = size(input)
	crop_x = (width*crop_factor).floor
	crop_y = (height*crop_factor).floor

	color1 = options[:color1]
	color2 = options[:color2]

	temp_file = Tempfile.new(["toaster", ".jpg"])

	`convert \\( "#{input}" \\) \\( -size #{crop_x}x#{crop_y} radial-gradient:#{color1}-#{color2} -gravity center -crop #{width}x#{height}+0+0 +repage \\) -compose multiply -flatten  "#{temp_file.path}"`
	temp_file.path
end

def kelvin(input)
	width, height = size(input)

	temp_file = Tempfile.new(["kelvin", ".jpg"])

	`convert \\( "#{input}" -auto-gamma -modulate 120,50,100 \\)  \\( -size #{width}x#{height} -fill rgba\\(255,153,0,0.5\\) -draw 'rectangle 0,0 #{width},#{height}' \\) -compose multiply "#{temp_file.path}"`
	frame temp_file.path, "Kelvin"
end

def tiltshift(input)

		temp_file = Tempfile.new(["tiltshift", ".jpg"])
	`convert \\( "#{input}" -gamma 0.75 -modulate 100,130 -contrast \\) \\( +clone -sparse-color Barycentric '0,0 black 0,%h white' -function polynomial 4,-4,1 -level 0,50% \\) -compose blur -set option:compose:args 5 -composite "#{temp_file.path}"`
     temp_file.path
end

def toaster(input) 
	toned= colortone(input, :color=>"#330000", :level=>100, :type=>0)
	toasted = convert(toned, "-modulate 150,80,100 -gamma 1.2 -contrast -contrast")

	first = vignette(toasted, :color1=>"none", :color2=>"LavenderBlush3")
	vignette(first, :color1=>"#ff9966", :color2=>"none")
end

def border(input, options={})
	options = {color: "black", width: 20}.merge(options)

	convert input, "-bordercolor #{options[:color]} -border #{options[:width]}x#{options[:width]}"
end

def gotham(input)
	temp_file = Tempfile.new(["gotham", ".jpg"])
	border convert input, "-modulate 120,10,100 -fill '#222b6d' -colorize 20 -gamma 0.5 -contrast -contrast"
end

main()
